<html>
  <head>
    <style>
      * {
        padding: 0;
        margin: 0;
      }
    </style>
  </head>

  <body>
    <div id="ytplayer" style="display: block"></div>
    <div id="twitch-embed" style="display: block">
      <iframe
        id="twitch-iframe"
        height="720"
        width="1280"
        frameborder="0"
        scrolling="no">
      </iframe>
    </div>
    <script type="text/javascript" src='./node_modules/obs-websocket-js/dist/obs-websocket.min.js'></script>
    <script type="text/javascript" src='./config.js'></script>

    <!-- obs controller -->
    <script>
      const obs = new OBSWebSocket();
      obs.connect({ address: 'localhost:4444'});

      obs.on('error', err => {
        console.error('socket error:', err);
      });

      async function stopStream() {
        obs.send('SetCurrentScene', {'scene-name': 'End'});
        await new Promise(resolve => setTimeout(resolve, 30000)); // sleep for 30 seconds
        obs.send('StopStreaming');
      }

      function setScene(sceneName) {
        obs.send('SetCurrentScene', {'scene-name': sceneName});        
      }

      function updateClipInfo(name, channel) {
        return obs.send('SetTextFreetype2Properties', { // need to change to SetTextGDIPlusProperties for Windows
          source: 'ClipInfo',
          text: `${name}\nBy - ${channel}`
        }).then(console.log('ClipInfo updated'));
      }

      function restartBrowser() {
        return obs.send('SetSceneItemProperties', { // hide
          item: 'Browser',
          visible: false,
        }).then(() => {
          obs.send('SetSceneItemProperties', { //show
            item: 'Browser',
            visible: true,
          });
        });
      }

      function updateStatusText(text) {
        return obs.send('SetTextFreetype2Properties', { // need to change to SetTextGDIPlusProperties for Windows
          source: 'StatusText',
          text,
        }).then(console.log('StatusText updated'));
      }
    </script>
    
    <!-- main functions -->
    <script>
      let errorCount = 0;
      let currentVideo;
      let player; // youtube embed

      async function startTwitch() {
        player.stopVideo();
        player.clearVideo();
        document.getElementById('ytplayer').style.display = 'none';

        document.getElementById('twitch-embed').style.display = 'block';
        document.getElementById('twitch-iframe').setAttribute('src', `https://clips.twitch.tv/embed?clip=${currentVideo.code}`);

        await new Promise(resolve => setTimeout(resolve, 31000)); // sleep for 31 seconds (bit of a hack but there is no other way currently)
        updateClip({_id: currentVideo._id}).then(() => {
          nextVideo();
        }).catch((error) => {
          updateStatusText('Could not update clip');
          // probably need to exit here
        });
      }

      function startYoutube() {
        document.getElementById('twitch-embed').style.display = 'none';
        document.getElementById('twitch-iframe').setAttribute('src', '');

        document.getElementById('ytplayer').style.display = 'block';
        player.loadVideoById(currentVideo.code);
      }
      
      function getNextVideo() {
        return new Promise((resolve, reject) => {
          fetch('http://localhost:3000/clips').then((output) => {
            output.json().then((output) => {
              console.log(`Retrieved next video ${output.url}`);
              resolve(output);
            }).catch((error) => {
              // probably need to stop
              reject(error)
            });
          }).catch((error) => {
            // probably need to stop
            reject(error);
          });
        })
      }

      function getTwitchVideoData(id) {
        return new Promise((resolve, reject) => {
          fetch(`https://api.twitch.tv/helix/clips?id=${id}`, {
            headers: new Headers({
              'client-id': twitchToken,
            }),
          }).then((res) => {
            return res.json();
          }).then((data) => {
            resolve(data.data[0]);
          }).catch((error) => {
            // TODO: find out if the type of error is defined (not found etc.)
            reject(error);
          });
        });
      }

      function getYoutubeVideoData(id) {
        return new Promise((resolve, reject) => {
          gapi.client.youtube.videos.list({
            part: 'snippet',
            id,
          }).then((output) => {
            if (output.result.items.length === 0) {
              reject({});
            } else {
              resolve(output.result.items[0].snippet);
            }
          }).catch((error) => {
            // TODO: find out if the type of error is defined (not found etc.)
            // can probably update with error and skip video
            reject(error);
          });
        });
      }
    </script>
    <script src='https://apis.google.com/js/client.js'></script>
    
    <script>
      function updateClip(body) {
        return fetch('http://localhost:3000/clips',
          {
            headers: {
              'Accept': 'application/json',
              'Content-Type': 'application/json'
            },
            method: 'POST',
            body: JSON.stringify(body),
          }
        );
      }

      async function nextVideo() {
        setScene('View');
        updateStatusText(' ');
        // get next video id from db
        getNextVideo().then((output) => {
          errorCount = 0;
          if(!output) {
            updateStatusText('No clips found, exiting');
            throw new Error('No clips found');
          }
          currentVideo = output;
          if (output.url.includes('youtube.com') || output.url.includes('youtu.be')) {
            startYoutube();
            getYoutubeVideoData(output.code).then((output) => {
              // update the ClipInfo text
              updateClipInfo(output.title, output.channelTitle);
            }).catch((error) => {
              console.error(error);
              updateClipInfo('Unable to get clip info', 'ERROR');
            });
          } else if (output.url.includes('twitch.tv')) {
            startTwitch();
            getTwitchVideoData(output.code).then((output) => {
              // update the ClipInfo text
              updateClipInfo(output.title, output.broadcaster_name);
            }).catch((error) => {
              console.error(error);
              updateClipInfo('Unable to get clip info', 'ERROR');
            });
          } else {
            // update video with error
            console.log('ERROR, invalid video');
            updateClip({_id: currentVideo._id, error: 1}).finally(() => {
              nextVideo();
            });
          }
        }).catch(async (error) => {
          setScene('Error');
          errorCount += 1;
          console.error(error);
          console.error(errorCount);
          // error, restart browser, update status text
          if (errorCount === 10) {
            updateStatusText('Failed to reconnect\nexiting stream');
            await new Promise(resolve => setTimeout(resolve, 5000)); // sleep for 5 seconds
            stopStream(); // exit stream
          } else {
            updateStatusText('Error, trying to reconnect');
            await new Promise(resolve => setTimeout(resolve, 2000)); // sleep for 2 seconds
            restartBrowser().finally(() => {
              nextVideo();
            });
          }
        });
      };
  
      // Load the IFrame Player API code asynchronously.
      let tag = document.createElement('script');
      tag.src = 'https://www.youtube.com/player_api';
      let firstScriptTag = document.getElementsByTagName('script')[0];
      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
  
      function onYouTubePlayerAPIReady() {
        gapi.client.setApiKey(apiKey);
        gapi.client.load('youtube', 'v3');
        player = new YT.Player('ytplayer', {
          height: '720',
          width: '1280',
          playerVars: {
            vq: 'hd720',
            controls: 0,
          },
          events: {
             // This is the main entry point. We need to ensure that the player has fully loaded before we begin
            'onReady': (event) => {
              nextVideo();
            },
            'onStateChange': (event) => {
              if(event.data === YT.PlayerState.ENDED) {
                // update previous video lastPlayed field
                updateClip({_id: currentVideo._id}).finally(() => {
                  nextVideo();
                });
              }
            },
            'onError': (event) => {
              const code = event.data;
              if (code === 2) {
                // invalid parameter
              } else if (code === 100) {
                // video removed or private
              } else if (code === 101 || code === 150) {
                // video cannot be embeded
              }
              console.error(event);
              updateClip({_id: currentVideo._id, error: 1});
              nextVideo();
            }
          }
        });
      }
    </script>
  </body>
</html>

